/* tslint:disable */
/* eslint-disable */
/**
 * Web2py marketplace demo
 * Web2py marketplace demo
 *
 * The version of the OpenAPI document: 0.0.1
 * Contact: mark@myire.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface AuthCas
 */
export interface AuthCas {
    /**
     * 
     * @type {string}
     * @memberof AuthCas
     */
    user_id?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthCas
     */
    service?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthCas
     */
    created_on?: string;
    /**
     * 
     * @type {boolean}
     * @memberof AuthCas
     */
    renew?: boolean;
    /**
     * 
     * @type {string}
     * @memberof AuthCas
     */
    ticket?: string;
    /**
     * 
     * @type {number}
     * @memberof AuthCas
     */
    id?: number;
}
/**
 * 
 * @export
 * @interface AuthEvent
 */
export interface AuthEvent {
    /**
     * 
     * @type {string}
     * @memberof AuthEvent
     */
    origin?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthEvent
     */
    client_ip?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthEvent
     */
    user_id?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthEvent
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthEvent
     */
    time_stamp?: string;
    /**
     * 
     * @type {number}
     * @memberof AuthEvent
     */
    id?: number;
}
/**
 * 
 * @export
 * @interface AuthGroup
 */
export interface AuthGroup {
    /**
     * 
     * @type {string}
     * @memberof AuthGroup
     */
    role?: string;
    /**
     * 
     * @type {number}
     * @memberof AuthGroup
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof AuthGroup
     */
    description?: string;
}
/**
 * 
 * @export
 * @interface AuthMembership
 */
export interface AuthMembership {
    /**
     * 
     * @type {string}
     * @memberof AuthMembership
     */
    group_id?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthMembership
     */
    user_id?: string;
    /**
     * 
     * @type {number}
     * @memberof AuthMembership
     */
    id?: number;
}
/**
 * 
 * @export
 * @interface AuthPermission
 */
export interface AuthPermission {
    /**
     * 
     * @type {number}
     * @memberof AuthPermission
     */
    record_id?: number;
    /**
     * 
     * @type {string}
     * @memberof AuthPermission
     */
    group_id?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthPermission
     */
    table_name?: string;
    /**
     * 
     * @type {number}
     * @memberof AuthPermission
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof AuthPermission
     */
    name?: string;
}
/**
 * 
 * @export
 * @interface AuthUser
 */
export interface AuthUser {
    /**
     * 
     * @type {string}
     * @memberof AuthUser
     */
    last_name?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthUser
     */
    first_name?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthUser
     */
    password?: string;
    /**
     * 
     * @type {number}
     * @memberof AuthUser
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof AuthUser
     */
    email?: string;
}
/**
 * 
 * @export
 * @interface GenericIdResponse
 */
export interface GenericIdResponse {
    /**
     * 
     * @type {string}
     * @memberof GenericIdResponse
     */
    id?: string;
}
/**
 * 
 * @export
 * @interface InventoryItem
 */
export interface InventoryItem {
    /**
     * 
     * @type {string}
     * @memberof InventoryItem
     */
    category?: string;
    /**
     * 
     * @type {string}
     * @memberof InventoryItem
     */
    idSeller?: string;
    /**
     * 
     * @type {string}
     * @memberof InventoryItem
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof InventoryItem
     */
    title?: string;
    /**
     * 
     * @type {string}
     * @memberof InventoryItem
     */
    image?: string;
    /**
     * 
     * @type {boolean}
     * @memberof InventoryItem
     */
    isPublic?: boolean;
    /**
     * 
     * @type {number}
     * @memberof InventoryItem
     */
    availableQuantity?: number;
    /**
     * 
     * @type {number}
     * @memberof InventoryItem
     */
    id?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof InventoryItem
     */
    tags?: Array<string>;
}
/**
 * 
 * @export
 * @interface PurchaseOrder
 */
export interface PurchaseOrder {
    /**
     * 
     * @type {number}
     * @memberof PurchaseOrder
     */
    id?: number;
    /**
     * 
     * @type {Array<InventoryItem>}
     * @memberof PurchaseOrder
     */
    inventoryItems?: Array<InventoryItem>;
    /**
     * 
     * @type {string}
     * @memberof PurchaseOrder
     */
    paymentStatus?: string;
}
/**
 * 
 * @export
 * @interface UserCredentials
 */
export interface UserCredentials {
    /**
     * 
     * @type {string}
     * @memberof UserCredentials
     */
    username?: string;
    /**
     * 
     * @type {string}
     * @memberof UserCredentials
     */
    password?: string;
}
/**
 * 
 * @export
 * @interface UserToken
 */
export interface UserToken {
    /**
     * 
     * @type {string}
     * @memberof UserToken
     */
    token?: string;
}

/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} entityName 
         * @param {InventoryItem | PurchaseOrder} inventoryItemPurchaseOrder 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEntity: async (entityName: string, inventoryItemPurchaseOrder: InventoryItem | PurchaseOrder, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'entityName' is not null or undefined
            if (entityName === null || entityName === undefined) {
                throw new RequiredError('entityName','Required parameter entityName was null or undefined when calling createEntity.');
            }
            // verify required parameter 'inventoryItemPurchaseOrder' is not null or undefined
            if (inventoryItemPurchaseOrder === null || inventoryItemPurchaseOrder === undefined) {
                throw new RequiredError('inventoryItemPurchaseOrder','Required parameter inventoryItemPurchaseOrder was null or undefined when calling createEntity.');
            }
            const localVarPath = `/entity/create/{entityName}`
                .replace(`{${"entityName"}}`, encodeURIComponent(String(entityName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof inventoryItemPurchaseOrder !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(inventoryItemPurchaseOrder !== undefined ? inventoryItemPurchaseOrder : {}) : (inventoryItemPurchaseOrder || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary /inventoryItem[inventoryItem]
         * @param {InventoryItem} inventoryItem 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteinventoryItem: async (inventoryItem: InventoryItem, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'inventoryItem' is not null or undefined
            if (inventoryItem === null || inventoryItem === undefined) {
                throw new RequiredError('inventoryItem','Required parameter inventoryItem was null or undefined when calling deleteinventoryItem.');
            }
            const localVarPath = `/autogenerated/api/inventoryItem`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof inventoryItem !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(inventoryItem !== undefined ? inventoryItem : {}) : (inventoryItem || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary /purchaseOrder[purchaseOrder]
         * @param {PurchaseOrder} purchaseOrder 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletepurchaseOrder: async (purchaseOrder: PurchaseOrder, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'purchaseOrder' is not null or undefined
            if (purchaseOrder === null || purchaseOrder === undefined) {
                throw new RequiredError('purchaseOrder','Required parameter purchaseOrder was null or undefined when calling deletepurchaseOrder.');
            }
            const localVarPath = `/autogenerated/api/purchaseOrder`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof purchaseOrder !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(purchaseOrder !== undefined ? purchaseOrder : {}) : (purchaseOrder || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} entityName 
         * @param {string} entityId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityById: async (entityName: string, entityId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'entityName' is not null or undefined
            if (entityName === null || entityName === undefined) {
                throw new RequiredError('entityName','Required parameter entityName was null or undefined when calling getEntityById.');
            }
            // verify required parameter 'entityId' is not null or undefined
            if (entityId === null || entityId === undefined) {
                throw new RequiredError('entityId','Required parameter entityId was null or undefined when calling getEntityById.');
            }
            const localVarPath = `/entity/entity/{entityName}/{entityId}`
                .replace(`{${"entityName"}}`, encodeURIComponent(String(entityName)))
                .replace(`{${"entityId"}}`, encodeURIComponent(String(entityId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} entityName 
         * @param {string} entityId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityDetails: async (entityName: string, entityId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'entityName' is not null or undefined
            if (entityName === null || entityName === undefined) {
                throw new RequiredError('entityName','Required parameter entityName was null or undefined when calling getEntityDetails.');
            }
            // verify required parameter 'entityId' is not null or undefined
            if (entityId === null || entityId === undefined) {
                throw new RequiredError('entityId','Required parameter entityId was null or undefined when calling getEntityDetails.');
            }
            const localVarPath = `/entity/details/{entityName}/{entityId}`
                .replace(`{${"entityName"}}`, encodeURIComponent(String(entityName)))
                .replace(`{${"entityId"}}`, encodeURIComponent(String(entityId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} entityName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityIndex: async (entityName: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'entityName' is not null or undefined
            if (entityName === null || entityName === undefined) {
                throw new RequiredError('entityName','Required parameter entityName was null or undefined when calling getEntityIndex.');
            }
            const localVarPath = `/entity/index/{entityName}`
                .replace(`{${"entityName"}}`, encodeURIComponent(String(entityName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary /inventoryItem/availableQuantity/{inventoryItem.availableQuantity.ge}/{inventoryItem.availableQuantity.lt}
         * @param {string} inventoryItemAvailableQuantityGe 
         * @param {string} inventoryItemAvailableQuantityLt 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getinventoryItemavailableQuantityInventoryItemAvailableQuantityGeInventoryItemAvailableQuantityLt: async (inventoryItemAvailableQuantityGe: string, inventoryItemAvailableQuantityLt: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'inventoryItemAvailableQuantityGe' is not null or undefined
            if (inventoryItemAvailableQuantityGe === null || inventoryItemAvailableQuantityGe === undefined) {
                throw new RequiredError('inventoryItemAvailableQuantityGe','Required parameter inventoryItemAvailableQuantityGe was null or undefined when calling getinventoryItemavailableQuantityInventoryItemAvailableQuantityGeInventoryItemAvailableQuantityLt.');
            }
            // verify required parameter 'inventoryItemAvailableQuantityLt' is not null or undefined
            if (inventoryItemAvailableQuantityLt === null || inventoryItemAvailableQuantityLt === undefined) {
                throw new RequiredError('inventoryItemAvailableQuantityLt','Required parameter inventoryItemAvailableQuantityLt was null or undefined when calling getinventoryItemavailableQuantityInventoryItemAvailableQuantityGeInventoryItemAvailableQuantityLt.');
            }
            const localVarPath = `/autogenerated/api/inventoryItem/availableQuantity/{InventoryItemAvailableQuantityGe}/{InventoryItemAvailableQuantityLt}`
                .replace(`{${"InventoryItemAvailableQuantityGe"}}`, encodeURIComponent(String(inventoryItemAvailableQuantityGe)))
                .replace(`{${"InventoryItemAvailableQuantityLt"}}`, encodeURIComponent(String(inventoryItemAvailableQuantityLt)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary /inventoryItem/availableQuantity/{inventoryItem.availableQuantity.ge}/{inventoryItem.availableQuantity.lt}/:field
         * @param {string} inventoryItemAvailableQuantityGe 
         * @param {string} inventoryItemAvailableQuantityLt 
         * @param {string} field 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getinventoryItemavailableQuantityInventoryItemAvailableQuantityGeInventoryItemAvailableQuantityLtfield: async (inventoryItemAvailableQuantityGe: string, inventoryItemAvailableQuantityLt: string, field: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'inventoryItemAvailableQuantityGe' is not null or undefined
            if (inventoryItemAvailableQuantityGe === null || inventoryItemAvailableQuantityGe === undefined) {
                throw new RequiredError('inventoryItemAvailableQuantityGe','Required parameter inventoryItemAvailableQuantityGe was null or undefined when calling getinventoryItemavailableQuantityInventoryItemAvailableQuantityGeInventoryItemAvailableQuantityLtfield.');
            }
            // verify required parameter 'inventoryItemAvailableQuantityLt' is not null or undefined
            if (inventoryItemAvailableQuantityLt === null || inventoryItemAvailableQuantityLt === undefined) {
                throw new RequiredError('inventoryItemAvailableQuantityLt','Required parameter inventoryItemAvailableQuantityLt was null or undefined when calling getinventoryItemavailableQuantityInventoryItemAvailableQuantityGeInventoryItemAvailableQuantityLtfield.');
            }
            // verify required parameter 'field' is not null or undefined
            if (field === null || field === undefined) {
                throw new RequiredError('field','Required parameter field was null or undefined when calling getinventoryItemavailableQuantityInventoryItemAvailableQuantityGeInventoryItemAvailableQuantityLtfield.');
            }
            const localVarPath = `/autogenerated/api/inventoryItem/availableQuantity/{InventoryItemAvailableQuantityGe}/{InventoryItemAvailableQuantityLt}/{field}`
                .replace(`{${"InventoryItemAvailableQuantityGe"}}`, encodeURIComponent(String(inventoryItemAvailableQuantityGe)))
                .replace(`{${"InventoryItemAvailableQuantityLt"}}`, encodeURIComponent(String(inventoryItemAvailableQuantityLt)))
                .replace(`{${"field"}}`, encodeURIComponent(String(field)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary /inventoryItem/id/{inventoryItem.id}
         * @param {string} inventoryItemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getinventoryItemidInventoryItemId: async (inventoryItemId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'inventoryItemId' is not null or undefined
            if (inventoryItemId === null || inventoryItemId === undefined) {
                throw new RequiredError('inventoryItemId','Required parameter inventoryItemId was null or undefined when calling getinventoryItemidInventoryItemId.');
            }
            const localVarPath = `/autogenerated/api/inventoryItem/id/{InventoryItemId}`
                .replace(`{${"InventoryItemId"}}`, encodeURIComponent(String(inventoryItemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary /inventoryItem/id/{inventoryItem.id}/:field
         * @param {string} inventoryItemId 
         * @param {string} field 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getinventoryItemidInventoryItemIdfield: async (inventoryItemId: string, field: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'inventoryItemId' is not null or undefined
            if (inventoryItemId === null || inventoryItemId === undefined) {
                throw new RequiredError('inventoryItemId','Required parameter inventoryItemId was null or undefined when calling getinventoryItemidInventoryItemIdfield.');
            }
            // verify required parameter 'field' is not null or undefined
            if (field === null || field === undefined) {
                throw new RequiredError('field','Required parameter field was null or undefined when calling getinventoryItemidInventoryItemIdfield.');
            }
            const localVarPath = `/autogenerated/api/inventoryItem/id/{InventoryItemId}/{field}`
                .replace(`{${"InventoryItemId"}}`, encodeURIComponent(String(inventoryItemId)))
                .replace(`{${"field"}}`, encodeURIComponent(String(field)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary /inventoryItem/idSeller/{inventoryItem.idSeller}
         * @param {string} inventoryItemIdSeller 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getinventoryItemidSellerInventoryItemIdSeller: async (inventoryItemIdSeller: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'inventoryItemIdSeller' is not null or undefined
            if (inventoryItemIdSeller === null || inventoryItemIdSeller === undefined) {
                throw new RequiredError('inventoryItemIdSeller','Required parameter inventoryItemIdSeller was null or undefined when calling getinventoryItemidSellerInventoryItemIdSeller.');
            }
            const localVarPath = `/autogenerated/api/inventoryItem/idSeller/{InventoryItemIdSeller}`
                .replace(`{${"InventoryItemIdSeller"}}`, encodeURIComponent(String(inventoryItemIdSeller)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary /inventoryItem/idSeller/{inventoryItem.idSeller}/:field
         * @param {string} inventoryItemIdSeller 
         * @param {string} field 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getinventoryItemidSellerInventoryItemIdSellerfield: async (inventoryItemIdSeller: string, field: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'inventoryItemIdSeller' is not null or undefined
            if (inventoryItemIdSeller === null || inventoryItemIdSeller === undefined) {
                throw new RequiredError('inventoryItemIdSeller','Required parameter inventoryItemIdSeller was null or undefined when calling getinventoryItemidSellerInventoryItemIdSellerfield.');
            }
            // verify required parameter 'field' is not null or undefined
            if (field === null || field === undefined) {
                throw new RequiredError('field','Required parameter field was null or undefined when calling getinventoryItemidSellerInventoryItemIdSellerfield.');
            }
            const localVarPath = `/autogenerated/api/inventoryItem/idSeller/{InventoryItemIdSeller}/{field}`
                .replace(`{${"InventoryItemIdSeller"}}`, encodeURIComponent(String(inventoryItemIdSeller)))
                .replace(`{${"field"}}`, encodeURIComponent(String(field)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary /inventoryItem/tags/{inventoryItem.tags.contains}
         * @param {string} inventoryItemTagsContains 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getinventoryItemtagsInventoryItemTagsContains: async (inventoryItemTagsContains: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'inventoryItemTagsContains' is not null or undefined
            if (inventoryItemTagsContains === null || inventoryItemTagsContains === undefined) {
                throw new RequiredError('inventoryItemTagsContains','Required parameter inventoryItemTagsContains was null or undefined when calling getinventoryItemtagsInventoryItemTagsContains.');
            }
            const localVarPath = `/autogenerated/api/inventoryItem/tags/{InventoryItemTagsContains}`
                .replace(`{${"InventoryItemTagsContains"}}`, encodeURIComponent(String(inventoryItemTagsContains)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary /inventoryItem/tags/{inventoryItem.tags.contains}/:field
         * @param {string} inventoryItemTagsContains 
         * @param {string} field 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getinventoryItemtagsInventoryItemTagsContainsfield: async (inventoryItemTagsContains: string, field: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'inventoryItemTagsContains' is not null or undefined
            if (inventoryItemTagsContains === null || inventoryItemTagsContains === undefined) {
                throw new RequiredError('inventoryItemTagsContains','Required parameter inventoryItemTagsContains was null or undefined when calling getinventoryItemtagsInventoryItemTagsContainsfield.');
            }
            // verify required parameter 'field' is not null or undefined
            if (field === null || field === undefined) {
                throw new RequiredError('field','Required parameter field was null or undefined when calling getinventoryItemtagsInventoryItemTagsContainsfield.');
            }
            const localVarPath = `/autogenerated/api/inventoryItem/tags/{InventoryItemTagsContains}/{field}`
                .replace(`{${"InventoryItemTagsContains"}}`, encodeURIComponent(String(inventoryItemTagsContains)))
                .replace(`{${"field"}}`, encodeURIComponent(String(field)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary /purchaseOrder/id/{purchaseOrder.id}
         * @param {string} purchaseOrderId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getpurchaseOrderidPurchaseOrderId: async (purchaseOrderId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'purchaseOrderId' is not null or undefined
            if (purchaseOrderId === null || purchaseOrderId === undefined) {
                throw new RequiredError('purchaseOrderId','Required parameter purchaseOrderId was null or undefined when calling getpurchaseOrderidPurchaseOrderId.');
            }
            const localVarPath = `/autogenerated/api/purchaseOrder/id/{PurchaseOrderId}`
                .replace(`{${"PurchaseOrderId"}}`, encodeURIComponent(String(purchaseOrderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary /purchaseOrder/id/{purchaseOrder.id}/:field
         * @param {string} purchaseOrderId 
         * @param {string} field 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getpurchaseOrderidPurchaseOrderIdfield: async (purchaseOrderId: string, field: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'purchaseOrderId' is not null or undefined
            if (purchaseOrderId === null || purchaseOrderId === undefined) {
                throw new RequiredError('purchaseOrderId','Required parameter purchaseOrderId was null or undefined when calling getpurchaseOrderidPurchaseOrderIdfield.');
            }
            // verify required parameter 'field' is not null or undefined
            if (field === null || field === undefined) {
                throw new RequiredError('field','Required parameter field was null or undefined when calling getpurchaseOrderidPurchaseOrderIdfield.');
            }
            const localVarPath = `/autogenerated/api/purchaseOrder/id/{PurchaseOrderId}/{field}`
                .replace(`{${"PurchaseOrderId"}}`, encodeURIComponent(String(purchaseOrderId)))
                .replace(`{${"field"}}`, encodeURIComponent(String(field)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary /purchaseOrder/inventoryItems/{purchaseOrder.inventoryItems.contains}
         * @param {string} purchaseOrderInventoryItemsContains 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getpurchaseOrderinventoryItemsPurchaseOrderInventoryItemsContains: async (purchaseOrderInventoryItemsContains: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'purchaseOrderInventoryItemsContains' is not null or undefined
            if (purchaseOrderInventoryItemsContains === null || purchaseOrderInventoryItemsContains === undefined) {
                throw new RequiredError('purchaseOrderInventoryItemsContains','Required parameter purchaseOrderInventoryItemsContains was null or undefined when calling getpurchaseOrderinventoryItemsPurchaseOrderInventoryItemsContains.');
            }
            const localVarPath = `/autogenerated/api/purchaseOrder/inventoryItems/{PurchaseOrderInventoryItemsContains}`
                .replace(`{${"PurchaseOrderInventoryItemsContains"}}`, encodeURIComponent(String(purchaseOrderInventoryItemsContains)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary /purchaseOrder/inventoryItems/{purchaseOrder.inventoryItems.contains}/:field
         * @param {string} purchaseOrderInventoryItemsContains 
         * @param {string} field 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getpurchaseOrderinventoryItemsPurchaseOrderInventoryItemsContainsfield: async (purchaseOrderInventoryItemsContains: string, field: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'purchaseOrderInventoryItemsContains' is not null or undefined
            if (purchaseOrderInventoryItemsContains === null || purchaseOrderInventoryItemsContains === undefined) {
                throw new RequiredError('purchaseOrderInventoryItemsContains','Required parameter purchaseOrderInventoryItemsContains was null or undefined when calling getpurchaseOrderinventoryItemsPurchaseOrderInventoryItemsContainsfield.');
            }
            // verify required parameter 'field' is not null or undefined
            if (field === null || field === undefined) {
                throw new RequiredError('field','Required parameter field was null or undefined when calling getpurchaseOrderinventoryItemsPurchaseOrderInventoryItemsContainsfield.');
            }
            const localVarPath = `/autogenerated/api/purchaseOrder/inventoryItems/{PurchaseOrderInventoryItemsContains}/{field}`
                .replace(`{${"PurchaseOrderInventoryItemsContains"}}`, encodeURIComponent(String(purchaseOrderInventoryItemsContains)))
                .replace(`{${"field"}}`, encodeURIComponent(String(field)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary /inventoryItem[inventoryItem]
         * @param {InventoryItem} inventoryItem 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postinventoryItem: async (inventoryItem: InventoryItem, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'inventoryItem' is not null or undefined
            if (inventoryItem === null || inventoryItem === undefined) {
                throw new RequiredError('inventoryItem','Required parameter inventoryItem was null or undefined when calling postinventoryItem.');
            }
            const localVarPath = `/autogenerated/api/inventoryItem`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof inventoryItem !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(inventoryItem !== undefined ? inventoryItem : {}) : (inventoryItem || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary /purchaseOrder[purchaseOrder]
         * @param {PurchaseOrder} purchaseOrder 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postpurchaseOrder: async (purchaseOrder: PurchaseOrder, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'purchaseOrder' is not null or undefined
            if (purchaseOrder === null || purchaseOrder === undefined) {
                throw new RequiredError('purchaseOrder','Required parameter purchaseOrder was null or undefined when calling postpurchaseOrder.');
            }
            const localVarPath = `/autogenerated/api/purchaseOrder`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof purchaseOrder !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(purchaseOrder !== undefined ? purchaseOrder : {}) : (purchaseOrder || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary /inventoryItem[inventoryItem]
         * @param {InventoryItem} inventoryItem 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putinventoryItem: async (inventoryItem: InventoryItem, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'inventoryItem' is not null or undefined
            if (inventoryItem === null || inventoryItem === undefined) {
                throw new RequiredError('inventoryItem','Required parameter inventoryItem was null or undefined when calling putinventoryItem.');
            }
            const localVarPath = `/autogenerated/api/inventoryItem`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof inventoryItem !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(inventoryItem !== undefined ? inventoryItem : {}) : (inventoryItem || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary /purchaseOrder[purchaseOrder]
         * @param {PurchaseOrder} purchaseOrder 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putpurchaseOrder: async (purchaseOrder: PurchaseOrder, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'purchaseOrder' is not null or undefined
            if (purchaseOrder === null || purchaseOrder === undefined) {
                throw new RequiredError('purchaseOrder','Required parameter purchaseOrder was null or undefined when calling putpurchaseOrder.');
            }
            const localVarPath = `/autogenerated/api/purchaseOrder`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof purchaseOrder !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(purchaseOrder !== undefined ? purchaseOrder : {}) : (purchaseOrder || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} entityName 
         * @param {string} entityId 
         * @param {InventoryItem | PurchaseOrder} inventoryItemPurchaseOrder 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEntity: async (entityName: string, entityId: string, inventoryItemPurchaseOrder: InventoryItem | PurchaseOrder, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'entityName' is not null or undefined
            if (entityName === null || entityName === undefined) {
                throw new RequiredError('entityName','Required parameter entityName was null or undefined when calling updateEntity.');
            }
            // verify required parameter 'entityId' is not null or undefined
            if (entityId === null || entityId === undefined) {
                throw new RequiredError('entityId','Required parameter entityId was null or undefined when calling updateEntity.');
            }
            // verify required parameter 'inventoryItemPurchaseOrder' is not null or undefined
            if (inventoryItemPurchaseOrder === null || inventoryItemPurchaseOrder === undefined) {
                throw new RequiredError('inventoryItemPurchaseOrder','Required parameter inventoryItemPurchaseOrder was null or undefined when calling updateEntity.');
            }
            const localVarPath = `/entity/update/{entityName}/{entityId}`
                .replace(`{${"entityName"}}`, encodeURIComponent(String(entityName)))
                .replace(`{${"entityId"}}`, encodeURIComponent(String(entityId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof inventoryItemPurchaseOrder !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(inventoryItemPurchaseOrder !== undefined ? inventoryItemPurchaseOrder : {}) : (inventoryItemPurchaseOrder || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {UserCredentials} userCredentials User Credentials to Authenticate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userAuthenticateCredentials: async (userCredentials: UserCredentials, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userCredentials' is not null or undefined
            if (userCredentials === null || userCredentials === undefined) {
                throw new RequiredError('userCredentials','Required parameter userCredentials was null or undefined when calling userAuthenticateCredentials.');
            }
            const localVarPath = `/user/authenticate_credentials`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof userCredentials !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(userCredentials !== undefined ? userCredentials : {}) : (userCredentials || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {UserToken} userToken User Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userAuthenticateToken: async (userToken: UserToken, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userToken' is not null or undefined
            if (userToken === null || userToken === undefined) {
                throw new RequiredError('userToken','Required parameter userToken was null or undefined when calling userAuthenticateToken.');
            }
            const localVarPath = `/user/authenticate_token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof userToken !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(userToken !== undefined ? userToken : {}) : (userToken || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {UserCredentials} userCredentials User Credentials to Authenticate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userRegisterCredentials: async (userCredentials: UserCredentials, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userCredentials' is not null or undefined
            if (userCredentials === null || userCredentials === undefined) {
                throw new RequiredError('userCredentials','Required parameter userCredentials was null or undefined when calling userRegisterCredentials.');
            }
            const localVarPath = `/user/register_credentials`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof userCredentials !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(userCredentials !== undefined ? userCredentials : {}) : (userCredentials || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} entityName 
         * @param {InventoryItem | PurchaseOrder} inventoryItemPurchaseOrder 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEntity(entityName: string, inventoryItemPurchaseOrder: InventoryItem | PurchaseOrder, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InventoryItem | PurchaseOrder>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).createEntity(entityName, inventoryItemPurchaseOrder, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary /inventoryItem[inventoryItem]
         * @param {InventoryItem} inventoryItem 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteinventoryItem(inventoryItem: InventoryItem, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<InventoryItem>>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).deleteinventoryItem(inventoryItem, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary /purchaseOrder[purchaseOrder]
         * @param {PurchaseOrder} purchaseOrder 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletepurchaseOrder(purchaseOrder: PurchaseOrder, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PurchaseOrder>>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).deletepurchaseOrder(purchaseOrder, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} entityName 
         * @param {string} entityId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEntityById(entityName: string, entityId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InventoryItem | PurchaseOrder>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).getEntityById(entityName, entityId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} entityName 
         * @param {string} entityId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEntityDetails(entityName: string, entityId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PurchaseOrder>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).getEntityDetails(entityName, entityId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} entityName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEntityIndex(entityName: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<InventoryItem | PurchaseOrder>>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).getEntityIndex(entityName, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary /inventoryItem/availableQuantity/{inventoryItem.availableQuantity.ge}/{inventoryItem.availableQuantity.lt}
         * @param {string} inventoryItemAvailableQuantityGe 
         * @param {string} inventoryItemAvailableQuantityLt 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getinventoryItemavailableQuantityInventoryItemAvailableQuantityGeInventoryItemAvailableQuantityLt(inventoryItemAvailableQuantityGe: string, inventoryItemAvailableQuantityLt: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<InventoryItem>>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).getinventoryItemavailableQuantityInventoryItemAvailableQuantityGeInventoryItemAvailableQuantityLt(inventoryItemAvailableQuantityGe, inventoryItemAvailableQuantityLt, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary /inventoryItem/availableQuantity/{inventoryItem.availableQuantity.ge}/{inventoryItem.availableQuantity.lt}/:field
         * @param {string} inventoryItemAvailableQuantityGe 
         * @param {string} inventoryItemAvailableQuantityLt 
         * @param {string} field 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getinventoryItemavailableQuantityInventoryItemAvailableQuantityGeInventoryItemAvailableQuantityLtfield(inventoryItemAvailableQuantityGe: string, inventoryItemAvailableQuantityLt: string, field: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<InventoryItem>>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).getinventoryItemavailableQuantityInventoryItemAvailableQuantityGeInventoryItemAvailableQuantityLtfield(inventoryItemAvailableQuantityGe, inventoryItemAvailableQuantityLt, field, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary /inventoryItem/id/{inventoryItem.id}
         * @param {string} inventoryItemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getinventoryItemidInventoryItemId(inventoryItemId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<InventoryItem>>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).getinventoryItemidInventoryItemId(inventoryItemId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary /inventoryItem/id/{inventoryItem.id}/:field
         * @param {string} inventoryItemId 
         * @param {string} field 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getinventoryItemidInventoryItemIdfield(inventoryItemId: string, field: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<InventoryItem>>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).getinventoryItemidInventoryItemIdfield(inventoryItemId, field, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary /inventoryItem/idSeller/{inventoryItem.idSeller}
         * @param {string} inventoryItemIdSeller 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getinventoryItemidSellerInventoryItemIdSeller(inventoryItemIdSeller: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<InventoryItem>>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).getinventoryItemidSellerInventoryItemIdSeller(inventoryItemIdSeller, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary /inventoryItem/idSeller/{inventoryItem.idSeller}/:field
         * @param {string} inventoryItemIdSeller 
         * @param {string} field 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getinventoryItemidSellerInventoryItemIdSellerfield(inventoryItemIdSeller: string, field: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<InventoryItem>>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).getinventoryItemidSellerInventoryItemIdSellerfield(inventoryItemIdSeller, field, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary /inventoryItem/tags/{inventoryItem.tags.contains}
         * @param {string} inventoryItemTagsContains 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getinventoryItemtagsInventoryItemTagsContains(inventoryItemTagsContains: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<InventoryItem>>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).getinventoryItemtagsInventoryItemTagsContains(inventoryItemTagsContains, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary /inventoryItem/tags/{inventoryItem.tags.contains}/:field
         * @param {string} inventoryItemTagsContains 
         * @param {string} field 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getinventoryItemtagsInventoryItemTagsContainsfield(inventoryItemTagsContains: string, field: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<InventoryItem>>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).getinventoryItemtagsInventoryItemTagsContainsfield(inventoryItemTagsContains, field, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary /purchaseOrder/id/{purchaseOrder.id}
         * @param {string} purchaseOrderId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getpurchaseOrderidPurchaseOrderId(purchaseOrderId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PurchaseOrder>>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).getpurchaseOrderidPurchaseOrderId(purchaseOrderId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary /purchaseOrder/id/{purchaseOrder.id}/:field
         * @param {string} purchaseOrderId 
         * @param {string} field 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getpurchaseOrderidPurchaseOrderIdfield(purchaseOrderId: string, field: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PurchaseOrder>>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).getpurchaseOrderidPurchaseOrderIdfield(purchaseOrderId, field, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary /purchaseOrder/inventoryItems/{purchaseOrder.inventoryItems.contains}
         * @param {string} purchaseOrderInventoryItemsContains 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getpurchaseOrderinventoryItemsPurchaseOrderInventoryItemsContains(purchaseOrderInventoryItemsContains: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PurchaseOrder>>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).getpurchaseOrderinventoryItemsPurchaseOrderInventoryItemsContains(purchaseOrderInventoryItemsContains, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary /purchaseOrder/inventoryItems/{purchaseOrder.inventoryItems.contains}/:field
         * @param {string} purchaseOrderInventoryItemsContains 
         * @param {string} field 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getpurchaseOrderinventoryItemsPurchaseOrderInventoryItemsContainsfield(purchaseOrderInventoryItemsContains: string, field: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PurchaseOrder>>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).getpurchaseOrderinventoryItemsPurchaseOrderInventoryItemsContainsfield(purchaseOrderInventoryItemsContains, field, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary /inventoryItem[inventoryItem]
         * @param {InventoryItem} inventoryItem 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postinventoryItem(inventoryItem: InventoryItem, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<InventoryItem>>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).postinventoryItem(inventoryItem, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary /purchaseOrder[purchaseOrder]
         * @param {PurchaseOrder} purchaseOrder 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postpurchaseOrder(purchaseOrder: PurchaseOrder, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PurchaseOrder>>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).postpurchaseOrder(purchaseOrder, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary /inventoryItem[inventoryItem]
         * @param {InventoryItem} inventoryItem 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putinventoryItem(inventoryItem: InventoryItem, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<InventoryItem>>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).putinventoryItem(inventoryItem, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary /purchaseOrder[purchaseOrder]
         * @param {PurchaseOrder} purchaseOrder 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putpurchaseOrder(purchaseOrder: PurchaseOrder, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PurchaseOrder>>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).putpurchaseOrder(purchaseOrder, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} entityName 
         * @param {string} entityId 
         * @param {InventoryItem | PurchaseOrder} inventoryItemPurchaseOrder 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateEntity(entityName: string, entityId: string, inventoryItemPurchaseOrder: InventoryItem | PurchaseOrder, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InventoryItem | PurchaseOrder>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).updateEntity(entityName, entityId, inventoryItemPurchaseOrder, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {UserCredentials} userCredentials User Credentials to Authenticate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userAuthenticateCredentials(userCredentials: UserCredentials, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserToken>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).userAuthenticateCredentials(userCredentials, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {UserToken} userToken User Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userAuthenticateToken(userToken: UserToken, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserToken>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).userAuthenticateToken(userToken, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {UserCredentials} userCredentials User Credentials to Authenticate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userRegisterCredentials(userCredentials: UserCredentials, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GenericIdResponse>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).userRegisterCredentials(userCredentials, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {string} entityName 
         * @param {InventoryItem | PurchaseOrder} inventoryItemPurchaseOrder 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEntity(entityName: string, inventoryItemPurchaseOrder: InventoryItem | PurchaseOrder, options?: any): AxiosPromise<InventoryItem | PurchaseOrder> {
            return DefaultApiFp(configuration).createEntity(entityName, inventoryItemPurchaseOrder, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary /inventoryItem[inventoryItem]
         * @param {InventoryItem} inventoryItem 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteinventoryItem(inventoryItem: InventoryItem, options?: any): AxiosPromise<Array<InventoryItem>> {
            return DefaultApiFp(configuration).deleteinventoryItem(inventoryItem, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary /purchaseOrder[purchaseOrder]
         * @param {PurchaseOrder} purchaseOrder 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletepurchaseOrder(purchaseOrder: PurchaseOrder, options?: any): AxiosPromise<Array<PurchaseOrder>> {
            return DefaultApiFp(configuration).deletepurchaseOrder(purchaseOrder, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} entityName 
         * @param {string} entityId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityById(entityName: string, entityId: string, options?: any): AxiosPromise<InventoryItem | PurchaseOrder> {
            return DefaultApiFp(configuration).getEntityById(entityName, entityId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} entityName 
         * @param {string} entityId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityDetails(entityName: string, entityId: string, options?: any): AxiosPromise<PurchaseOrder> {
            return DefaultApiFp(configuration).getEntityDetails(entityName, entityId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} entityName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityIndex(entityName: string, options?: any): AxiosPromise<Array<InventoryItem | PurchaseOrder>> {
            return DefaultApiFp(configuration).getEntityIndex(entityName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary /inventoryItem/availableQuantity/{inventoryItem.availableQuantity.ge}/{inventoryItem.availableQuantity.lt}
         * @param {string} inventoryItemAvailableQuantityGe 
         * @param {string} inventoryItemAvailableQuantityLt 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getinventoryItemavailableQuantityInventoryItemAvailableQuantityGeInventoryItemAvailableQuantityLt(inventoryItemAvailableQuantityGe: string, inventoryItemAvailableQuantityLt: string, options?: any): AxiosPromise<Array<InventoryItem>> {
            return DefaultApiFp(configuration).getinventoryItemavailableQuantityInventoryItemAvailableQuantityGeInventoryItemAvailableQuantityLt(inventoryItemAvailableQuantityGe, inventoryItemAvailableQuantityLt, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary /inventoryItem/availableQuantity/{inventoryItem.availableQuantity.ge}/{inventoryItem.availableQuantity.lt}/:field
         * @param {string} inventoryItemAvailableQuantityGe 
         * @param {string} inventoryItemAvailableQuantityLt 
         * @param {string} field 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getinventoryItemavailableQuantityInventoryItemAvailableQuantityGeInventoryItemAvailableQuantityLtfield(inventoryItemAvailableQuantityGe: string, inventoryItemAvailableQuantityLt: string, field: string, options?: any): AxiosPromise<Array<InventoryItem>> {
            return DefaultApiFp(configuration).getinventoryItemavailableQuantityInventoryItemAvailableQuantityGeInventoryItemAvailableQuantityLtfield(inventoryItemAvailableQuantityGe, inventoryItemAvailableQuantityLt, field, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary /inventoryItem/id/{inventoryItem.id}
         * @param {string} inventoryItemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getinventoryItemidInventoryItemId(inventoryItemId: string, options?: any): AxiosPromise<Array<InventoryItem>> {
            return DefaultApiFp(configuration).getinventoryItemidInventoryItemId(inventoryItemId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary /inventoryItem/id/{inventoryItem.id}/:field
         * @param {string} inventoryItemId 
         * @param {string} field 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getinventoryItemidInventoryItemIdfield(inventoryItemId: string, field: string, options?: any): AxiosPromise<Array<InventoryItem>> {
            return DefaultApiFp(configuration).getinventoryItemidInventoryItemIdfield(inventoryItemId, field, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary /inventoryItem/idSeller/{inventoryItem.idSeller}
         * @param {string} inventoryItemIdSeller 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getinventoryItemidSellerInventoryItemIdSeller(inventoryItemIdSeller: string, options?: any): AxiosPromise<Array<InventoryItem>> {
            return DefaultApiFp(configuration).getinventoryItemidSellerInventoryItemIdSeller(inventoryItemIdSeller, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary /inventoryItem/idSeller/{inventoryItem.idSeller}/:field
         * @param {string} inventoryItemIdSeller 
         * @param {string} field 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getinventoryItemidSellerInventoryItemIdSellerfield(inventoryItemIdSeller: string, field: string, options?: any): AxiosPromise<Array<InventoryItem>> {
            return DefaultApiFp(configuration).getinventoryItemidSellerInventoryItemIdSellerfield(inventoryItemIdSeller, field, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary /inventoryItem/tags/{inventoryItem.tags.contains}
         * @param {string} inventoryItemTagsContains 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getinventoryItemtagsInventoryItemTagsContains(inventoryItemTagsContains: string, options?: any): AxiosPromise<Array<InventoryItem>> {
            return DefaultApiFp(configuration).getinventoryItemtagsInventoryItemTagsContains(inventoryItemTagsContains, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary /inventoryItem/tags/{inventoryItem.tags.contains}/:field
         * @param {string} inventoryItemTagsContains 
         * @param {string} field 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getinventoryItemtagsInventoryItemTagsContainsfield(inventoryItemTagsContains: string, field: string, options?: any): AxiosPromise<Array<InventoryItem>> {
            return DefaultApiFp(configuration).getinventoryItemtagsInventoryItemTagsContainsfield(inventoryItemTagsContains, field, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary /purchaseOrder/id/{purchaseOrder.id}
         * @param {string} purchaseOrderId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getpurchaseOrderidPurchaseOrderId(purchaseOrderId: string, options?: any): AxiosPromise<Array<PurchaseOrder>> {
            return DefaultApiFp(configuration).getpurchaseOrderidPurchaseOrderId(purchaseOrderId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary /purchaseOrder/id/{purchaseOrder.id}/:field
         * @param {string} purchaseOrderId 
         * @param {string} field 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getpurchaseOrderidPurchaseOrderIdfield(purchaseOrderId: string, field: string, options?: any): AxiosPromise<Array<PurchaseOrder>> {
            return DefaultApiFp(configuration).getpurchaseOrderidPurchaseOrderIdfield(purchaseOrderId, field, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary /purchaseOrder/inventoryItems/{purchaseOrder.inventoryItems.contains}
         * @param {string} purchaseOrderInventoryItemsContains 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getpurchaseOrderinventoryItemsPurchaseOrderInventoryItemsContains(purchaseOrderInventoryItemsContains: string, options?: any): AxiosPromise<Array<PurchaseOrder>> {
            return DefaultApiFp(configuration).getpurchaseOrderinventoryItemsPurchaseOrderInventoryItemsContains(purchaseOrderInventoryItemsContains, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary /purchaseOrder/inventoryItems/{purchaseOrder.inventoryItems.contains}/:field
         * @param {string} purchaseOrderInventoryItemsContains 
         * @param {string} field 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getpurchaseOrderinventoryItemsPurchaseOrderInventoryItemsContainsfield(purchaseOrderInventoryItemsContains: string, field: string, options?: any): AxiosPromise<Array<PurchaseOrder>> {
            return DefaultApiFp(configuration).getpurchaseOrderinventoryItemsPurchaseOrderInventoryItemsContainsfield(purchaseOrderInventoryItemsContains, field, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary /inventoryItem[inventoryItem]
         * @param {InventoryItem} inventoryItem 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postinventoryItem(inventoryItem: InventoryItem, options?: any): AxiosPromise<Array<InventoryItem>> {
            return DefaultApiFp(configuration).postinventoryItem(inventoryItem, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary /purchaseOrder[purchaseOrder]
         * @param {PurchaseOrder} purchaseOrder 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postpurchaseOrder(purchaseOrder: PurchaseOrder, options?: any): AxiosPromise<Array<PurchaseOrder>> {
            return DefaultApiFp(configuration).postpurchaseOrder(purchaseOrder, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary /inventoryItem[inventoryItem]
         * @param {InventoryItem} inventoryItem 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putinventoryItem(inventoryItem: InventoryItem, options?: any): AxiosPromise<Array<InventoryItem>> {
            return DefaultApiFp(configuration).putinventoryItem(inventoryItem, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary /purchaseOrder[purchaseOrder]
         * @param {PurchaseOrder} purchaseOrder 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putpurchaseOrder(purchaseOrder: PurchaseOrder, options?: any): AxiosPromise<Array<PurchaseOrder>> {
            return DefaultApiFp(configuration).putpurchaseOrder(purchaseOrder, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} entityName 
         * @param {string} entityId 
         * @param {InventoryItem | PurchaseOrder} inventoryItemPurchaseOrder 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEntity(entityName: string, entityId: string, inventoryItemPurchaseOrder: InventoryItem | PurchaseOrder, options?: any): AxiosPromise<InventoryItem | PurchaseOrder> {
            return DefaultApiFp(configuration).updateEntity(entityName, entityId, inventoryItemPurchaseOrder, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {UserCredentials} userCredentials User Credentials to Authenticate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userAuthenticateCredentials(userCredentials: UserCredentials, options?: any): AxiosPromise<UserToken> {
            return DefaultApiFp(configuration).userAuthenticateCredentials(userCredentials, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {UserToken} userToken User Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userAuthenticateToken(userToken: UserToken, options?: any): AxiosPromise<UserToken> {
            return DefaultApiFp(configuration).userAuthenticateToken(userToken, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {UserCredentials} userCredentials User Credentials to Authenticate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userRegisterCredentials(userCredentials: UserCredentials, options?: any): AxiosPromise<GenericIdResponse> {
            return DefaultApiFp(configuration).userRegisterCredentials(userCredentials, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
    /**
     * 
     * @param {string} entityName 
     * @param {InventoryItem | PurchaseOrder} inventoryItemPurchaseOrder 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public createEntity(entityName: string, inventoryItemPurchaseOrder: InventoryItem | PurchaseOrder, options?: any) {
        return DefaultApiFp(this.configuration).createEntity(entityName, inventoryItemPurchaseOrder, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary /inventoryItem[inventoryItem]
     * @param {InventoryItem} inventoryItem 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public deleteinventoryItem(inventoryItem: InventoryItem, options?: any) {
        return DefaultApiFp(this.configuration).deleteinventoryItem(inventoryItem, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary /purchaseOrder[purchaseOrder]
     * @param {PurchaseOrder} purchaseOrder 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public deletepurchaseOrder(purchaseOrder: PurchaseOrder, options?: any) {
        return DefaultApiFp(this.configuration).deletepurchaseOrder(purchaseOrder, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} entityName 
     * @param {string} entityId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getEntityById(entityName: string, entityId: string, options?: any) {
        return DefaultApiFp(this.configuration).getEntityById(entityName, entityId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} entityName 
     * @param {string} entityId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getEntityDetails(entityName: string, entityId: string, options?: any) {
        return DefaultApiFp(this.configuration).getEntityDetails(entityName, entityId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} entityName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getEntityIndex(entityName: string, options?: any) {
        return DefaultApiFp(this.configuration).getEntityIndex(entityName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary /inventoryItem/availableQuantity/{inventoryItem.availableQuantity.ge}/{inventoryItem.availableQuantity.lt}
     * @param {string} inventoryItemAvailableQuantityGe 
     * @param {string} inventoryItemAvailableQuantityLt 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getinventoryItemavailableQuantityInventoryItemAvailableQuantityGeInventoryItemAvailableQuantityLt(inventoryItemAvailableQuantityGe: string, inventoryItemAvailableQuantityLt: string, options?: any) {
        return DefaultApiFp(this.configuration).getinventoryItemavailableQuantityInventoryItemAvailableQuantityGeInventoryItemAvailableQuantityLt(inventoryItemAvailableQuantityGe, inventoryItemAvailableQuantityLt, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary /inventoryItem/availableQuantity/{inventoryItem.availableQuantity.ge}/{inventoryItem.availableQuantity.lt}/:field
     * @param {string} inventoryItemAvailableQuantityGe 
     * @param {string} inventoryItemAvailableQuantityLt 
     * @param {string} field 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getinventoryItemavailableQuantityInventoryItemAvailableQuantityGeInventoryItemAvailableQuantityLtfield(inventoryItemAvailableQuantityGe: string, inventoryItemAvailableQuantityLt: string, field: string, options?: any) {
        return DefaultApiFp(this.configuration).getinventoryItemavailableQuantityInventoryItemAvailableQuantityGeInventoryItemAvailableQuantityLtfield(inventoryItemAvailableQuantityGe, inventoryItemAvailableQuantityLt, field, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary /inventoryItem/id/{inventoryItem.id}
     * @param {string} inventoryItemId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getinventoryItemidInventoryItemId(inventoryItemId: string, options?: any) {
        return DefaultApiFp(this.configuration).getinventoryItemidInventoryItemId(inventoryItemId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary /inventoryItem/id/{inventoryItem.id}/:field
     * @param {string} inventoryItemId 
     * @param {string} field 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getinventoryItemidInventoryItemIdfield(inventoryItemId: string, field: string, options?: any) {
        return DefaultApiFp(this.configuration).getinventoryItemidInventoryItemIdfield(inventoryItemId, field, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary /inventoryItem/idSeller/{inventoryItem.idSeller}
     * @param {string} inventoryItemIdSeller 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getinventoryItemidSellerInventoryItemIdSeller(inventoryItemIdSeller: string, options?: any) {
        return DefaultApiFp(this.configuration).getinventoryItemidSellerInventoryItemIdSeller(inventoryItemIdSeller, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary /inventoryItem/idSeller/{inventoryItem.idSeller}/:field
     * @param {string} inventoryItemIdSeller 
     * @param {string} field 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getinventoryItemidSellerInventoryItemIdSellerfield(inventoryItemIdSeller: string, field: string, options?: any) {
        return DefaultApiFp(this.configuration).getinventoryItemidSellerInventoryItemIdSellerfield(inventoryItemIdSeller, field, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary /inventoryItem/tags/{inventoryItem.tags.contains}
     * @param {string} inventoryItemTagsContains 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getinventoryItemtagsInventoryItemTagsContains(inventoryItemTagsContains: string, options?: any) {
        return DefaultApiFp(this.configuration).getinventoryItemtagsInventoryItemTagsContains(inventoryItemTagsContains, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary /inventoryItem/tags/{inventoryItem.tags.contains}/:field
     * @param {string} inventoryItemTagsContains 
     * @param {string} field 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getinventoryItemtagsInventoryItemTagsContainsfield(inventoryItemTagsContains: string, field: string, options?: any) {
        return DefaultApiFp(this.configuration).getinventoryItemtagsInventoryItemTagsContainsfield(inventoryItemTagsContains, field, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary /purchaseOrder/id/{purchaseOrder.id}
     * @param {string} purchaseOrderId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getpurchaseOrderidPurchaseOrderId(purchaseOrderId: string, options?: any) {
        return DefaultApiFp(this.configuration).getpurchaseOrderidPurchaseOrderId(purchaseOrderId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary /purchaseOrder/id/{purchaseOrder.id}/:field
     * @param {string} purchaseOrderId 
     * @param {string} field 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getpurchaseOrderidPurchaseOrderIdfield(purchaseOrderId: string, field: string, options?: any) {
        return DefaultApiFp(this.configuration).getpurchaseOrderidPurchaseOrderIdfield(purchaseOrderId, field, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary /purchaseOrder/inventoryItems/{purchaseOrder.inventoryItems.contains}
     * @param {string} purchaseOrderInventoryItemsContains 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getpurchaseOrderinventoryItemsPurchaseOrderInventoryItemsContains(purchaseOrderInventoryItemsContains: string, options?: any) {
        return DefaultApiFp(this.configuration).getpurchaseOrderinventoryItemsPurchaseOrderInventoryItemsContains(purchaseOrderInventoryItemsContains, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary /purchaseOrder/inventoryItems/{purchaseOrder.inventoryItems.contains}/:field
     * @param {string} purchaseOrderInventoryItemsContains 
     * @param {string} field 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getpurchaseOrderinventoryItemsPurchaseOrderInventoryItemsContainsfield(purchaseOrderInventoryItemsContains: string, field: string, options?: any) {
        return DefaultApiFp(this.configuration).getpurchaseOrderinventoryItemsPurchaseOrderInventoryItemsContainsfield(purchaseOrderInventoryItemsContains, field, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary /inventoryItem[inventoryItem]
     * @param {InventoryItem} inventoryItem 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public postinventoryItem(inventoryItem: InventoryItem, options?: any) {
        return DefaultApiFp(this.configuration).postinventoryItem(inventoryItem, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary /purchaseOrder[purchaseOrder]
     * @param {PurchaseOrder} purchaseOrder 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public postpurchaseOrder(purchaseOrder: PurchaseOrder, options?: any) {
        return DefaultApiFp(this.configuration).postpurchaseOrder(purchaseOrder, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary /inventoryItem[inventoryItem]
     * @param {InventoryItem} inventoryItem 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public putinventoryItem(inventoryItem: InventoryItem, options?: any) {
        return DefaultApiFp(this.configuration).putinventoryItem(inventoryItem, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary /purchaseOrder[purchaseOrder]
     * @param {PurchaseOrder} purchaseOrder 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public putpurchaseOrder(purchaseOrder: PurchaseOrder, options?: any) {
        return DefaultApiFp(this.configuration).putpurchaseOrder(purchaseOrder, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} entityName 
     * @param {string} entityId 
     * @param {InventoryItem | PurchaseOrder} inventoryItemPurchaseOrder 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public updateEntity(entityName: string, entityId: string, inventoryItemPurchaseOrder: InventoryItem | PurchaseOrder, options?: any) {
        return DefaultApiFp(this.configuration).updateEntity(entityName, entityId, inventoryItemPurchaseOrder, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UserCredentials} userCredentials User Credentials to Authenticate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public userAuthenticateCredentials(userCredentials: UserCredentials, options?: any) {
        return DefaultApiFp(this.configuration).userAuthenticateCredentials(userCredentials, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UserToken} userToken User Token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public userAuthenticateToken(userToken: UserToken, options?: any) {
        return DefaultApiFp(this.configuration).userAuthenticateToken(userToken, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UserCredentials} userCredentials User Credentials to Authenticate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public userRegisterCredentials(userCredentials: UserCredentials, options?: any) {
        return DefaultApiFp(this.configuration).userRegisterCredentials(userCredentials, options).then((request) => request(this.axios, this.basePath));
    }
}


